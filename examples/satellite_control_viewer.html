
<!DOCTYPE html>
<html>
<head>
    <title>Satellite Attitude Control</title>
    <style>
        body { font-family: sans-serif; background: #000; color: #fff; display: flex; flex-direction: column; align-items: center; }
        canvas { border: 1px solid #444; }
    </style>
</head>
<body>
    <h1>Satellite Control (PD)</h1>
    <p>Target: Stationary aligned with axes.</p>
    <canvas id="simCanvas" width="600" height="600"></canvas>
    <script>
        const history = [[0.7071067690849304, 0.7071067690849304, 0.0, 0.0], [0.9939060807228088, 0.10714782774448395, -0.024257775396108627, -0.009037190116941929]];
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const scale = 150; 
        
        // Satellite Geometry (Box + Solar Panels)
        const body_verts = [
            [-0.5,-0.5,0.5], [0.5,-0.5,0.5], [0.5,0.5,0.5], [-0.5,0.5,0.5], // Front
            [-0.5,-0.5,-0.5], [0.5,-0.5,-0.5], [0.5,0.5,-0.5], [-0.5,0.5,-0.5] // Back
        ];
        
        const panel_left = [ [-1.5, -0.2, 0], [-0.5, -0.2, 0], [-0.5, 0.2, 0], [-1.5, 0.2, 0] ];
        const panel_right = [ [0.5, -0.2, 0], [1.5, -0.2, 0], [1.5, 0.2, 0], [0.5, 0.2, 0] ];
        
        let frame = 0;
        
        function rotateByQuat(v, q) {
            const [w, x, y, z] = q;
            const [vx, vy, vz] = v;
            const x2 = x + x, y2 = y + y, z2 = z + z;
            const xx = x * x2, xy = x * y2, xz = x * z2;
            const yy = y * y2, yz = y * z2, zz = z * z2;
            const wx = w * x2, wy = w * y2, wz = w * z2;
            return [
                (1 - (yy + zz)) * vx + (xy - wz) * vy + (xz + wy) * vz,
                (xy + wz) * vx + (1 - (xx + zz)) * vy + (yz - wx) * vz,
                (xz - wy) * vx + (yz + wx) * vy + (1 - (xx + yy)) * vz
            ];
        }
        
        function drawPoly(pts, q, fillStyle, strokeStyle, ox, oy) {
            ctx.beginPath();
            let first = true;
            for(let v of pts) {
                const r = rotateByQuat(v, q);
                const x = ox + r[0]*scale;
                const y = oy - r[1]*scale;
                if(first) { ctx.moveTo(x,y); first=false; }
                else ctx.lineTo(x,y);
            }
            ctx.closePath();
            ctx.fillStyle = fillStyle;
            ctx.fill();
            ctx.strokeStyle = strokeStyle;
            ctx.stroke();
        }
        
        function draw() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0,0, canvas.width, canvas.height);
            
            const qs = history[frame];
            const show = Array.isArray(qs[0]) ? qs : [qs];
            const grid = Math.ceil(Math.sqrt(show.length));
            
            // Draw Target Frame (Ghost) - Faint
            // Identity quaternion is [1,0,0,0] -> No rotation.
            // Just raw projection.
            // drawAxes([1,0,0,0], 0.2); 
            
            // Draw Satellite
            // We need proper depth sorting or just simple wireframe.
            // Simple painter's alg is hard without Z-sort.
            // Let's just draw wireframe panels and body.
            
            show.forEach((q, idx) => {
                const gx = idx % grid;
                const gy = Math.floor(idx / grid);
                const ox = cx + (gx - (grid - 1)/2) * 240;
                const oy = cy + (gy - (grid - 1)/2) * 240;

                drawPoly(panel_left, q, 'rgba(0,0,255,0.5)', '#0af', ox, oy);
                drawPoly(panel_right, q, 'rgba(0,0,255,0.5)', '#0af', ox, oy);
                
                const r_verts = body_verts.map(v => rotateByQuat(v, q));
                const proj = r_verts.map(v => [ox + v[0]*scale, oy - v[1]*scale]);
                
                ctx.strokeStyle = '#ddd';
                const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
                ctx.beginPath();
                for(let e of edges) {
                    ctx.moveTo(proj[e[0]][0], proj[e[0]][1]);
                    ctx.lineTo(proj[e[1]][0], proj[e[1]][1]);
                }
                ctx.stroke();
                
                const axes = [[1,0,0], [0,1,0], [0,0,1]];
                const colors = ['#f00', '#0f0', '#00f'];
                for(let i=0; i<3; i++) {
                    const r = rotateByQuat(axes[i], q);
                    ctx.strokeStyle = colors[i];
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(ox, oy);
                    ctx.lineTo(ox + r[0]*scale, oy - r[1]*scale);
                    ctx.stroke();
                }
            });

            frame = (frame + 1);
            if(frame >= history.length) frame = history.length - 1; // Hold at end
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>
    